package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
		
		/*
		 1.상속(is a : ~은 ~이다)
		  - 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		  - 적은 양의 코드로 새로운 클래스를 작성할수있다.
		  - 새로 작성하고자하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을
		  	키워드 'extends'와 함께 써주기만 하면된다.
		  	
		  	class Child extends Parent{
		  	
		  	}
		 
		  - 상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다.
		   : 조상클래스 - 부모클래스, 상위클래스, 기반클래스
		   : 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
		   
		  - 멤버만 상속 받는다. 멤버(멤버변수-클래스변수,인스턴스변수) (메서드- 클래스메서드,인스턴스메서드) 	
		  - 자손클래스의 멤버의 개수는 조상클래스 보다 같거나 많다. 
		 
		 2.포함(has a : ~은 ~을 포함하고있다) 
		  - 상속이외에 클래스를 재사용하는 방법
		  - 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법
		  - 
		 
		 3. 단일상속
		  - 자바에서는 단일상속(두개이상은 불가능)만 가능하다.
		  	class TVCR extends TV, VCR{ //상속두개 불가능
		  	
		  	}
		 	
		  - Tv와 VCR에 동일한 멤버가 있을때 어떤것을 상속받을지 알수 없다.
		  - VCR의 멤버명을 바꾼다면 그동안 VCR의 멤버를 사용하던 부분들을 모두 수정해주어야한다.
		  - 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할수 있다.
		  
		 4. Object클래스 (모든 클래스의 조상)
		  - 모든 클래스의 상속 계층도의 가장위에 위치하는 조상 클래스이다.
		  - 다른클래스로부터 상속받지 않는 클래스들은 자동적으로 Object클래스를 상속받는다.
		  
		  class Tv{
		  
		  }
		  => 컴파일후
		  class Tv extends Object{

		  }
		  
		 - toString()나 equals()와 같은 메서드를 따로 정의하지 않고 사용할 수 있는것은
		  Object클래스에 정의된 것들이기 때문이다.
		 
		  
		 5. 오버라이드(override)
		  - 조상클래스로부터 상속받은 메서드의 내용을 변경(재정의)하는 것.
		  - 오버라이드 되기 위한 조건 => 선언부가 일치 해야 한다.
		  - 오버라이드에서 호출되면 자식것이 먼저된다.
		  - 행위는 같지만 구체적인 행위(구현부)는 다르다.
		    : 자손클래스에서 오버라이드하는 메서드는 조상클래스의 메서드의 명과 동일해야한다.
		    : 매개변수의 타입과 개수가 같아야 한다. !(타입x || 개수x) => 타입 o && 개수 o
		    : 리턴타입이 같아야한다.(선언부가 일치해야한다.)
		    : 접근제어자를 조상클래스보다 좁은 범위로 설정할수 없다.(public,private)
		    : 예외는 조상클래스의 메서드보다 많이 선언할수없다.
		    
		    
		  6. super.
		   - 조상클래스의 멤버와 자손클래스의 멤버가 중복정의 되어 있을때 서로 구분하기 위해 사용한다.
		   - 조상멤버와 자신의 멤버를 구별하는데 사용한다는 것을 제외하고는 this.과 근본적으로 동일
		   - static메서드에서 사용할 수 없다. //자식에 있는 클래스메서드에서 인스턴스 친구들을 부를수없다. this.이 인스턴스에 라는 의미]
		   
		  7. super() - 조상클래스의 생성자를 호출할때 사용
		   - this()와 마찬가지로 super()역시 생성자 이다.
		   - this()는 같은 클래스의 다른 생성자를 호출 
		     super()는 부모클래스의 생성자를 호출
		   - 생성자의 첫 줄에는 조상 클래스의 생성자를 호출해야한다.
		      자손클래스의 멤버가 조상클래스의 멤버를 사용할수 있음으로 조상의 멤버들이 먼저
		      초기화 되어야 한다.
		     
		    8. 제어자
		     - 클래스, 변수 메서드의 선언부에 사용된다.
		     - 접근제어자와 그 외 제어자로 나누어진다.
		     - 접근제어자 : private(클래스내), default(같은패키지내,클래스명 변수명 메서드명앞에서 아무것도 안쓰면 디폴트), protected(패키지내에서 쓰는거 다른패키지에 자손), public (어디서든 사용가능)
		     - 그외 제어자 : static, final, abstract, native....
		     - 접근제어자를 제일 왼쪽에 많이 둔다.
		     - static(클래스의 , 공통적인)
		      : 멤버변수, 메서드, 초기화 블럭 사용된다.
		      : static 변수
		       -> 모든인스턴스에서 공통적으로 사용한다.
		       -> 인스턴스를 생성하지 않고도 호출할수있다.
		       -> 클래스가 메모리에 로드될때 생성된다.
		      : static 메서드
		       -> 인스턴스 생성없이 사용 가능
		       -> 클래스 메서드 내에서 인스턴스 멤버를 호출할 수 없다.
		       
		      - final(마지막의, 변경할수없는)
		       : 변수에 사용시 변경할수없는 상수가된다.
		       : 메서드에 사용시 오버라이드 할수 없다.
		       : 클래스에 사용시 상속(확장개념)할수 없는 클래스가 된다.
		       
		      - abstract(추상의, 미완성된)
		       : 메서드와 클래스에만 사용가능 변수안됨
		       : 메서드(선언부,구현부)에 사용시 구현부는 작성하지 않는다.
		        void method();
		        
		     9. 접근제어자
		      - private : 같은 클래스내에서 접근가능
		      - default : 같은 패키지내에서 접근가능
		      - protected : 같은 패키지 + 다른 패키지의 자손클래스에서 접근 가능
		      - public : 접근제한이 없다.
		      - 클래스에는 default(패키지를 벗어나면 못쓴다), public사용 가능
		           
		     10. 캡슐화
		      - 접근제어잘르 사용하는 이유
		       : 외부로부터 데이터를 보호하기 위한 목적
		       : 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해 사용
		       
		     11. 다형성(polymorphism)  
		      - 여러가지 형태를 가질수 있는 능력
		      - 한 타입의 참조변수로 여러 타입의 객체를 참조할 수있다.
		       Car c = new FireCar();
		       Car c = new Ambulance();
		      - 부모타입의 참조변수로 자손타입의 인스턴스를 참조할수있다.
		      
		     12. 참조변수의 형변환 (상속)
		      - 서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
		      - 자손타입 -> 부모타입(up-casting) : 형변환 생략 가능
		      - 부모타입 -> 자손타입(down-casting) : 형변환 생략 불가
		      
		     13. instanceof  
		      - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
		      - 연산결과가 true이면 참조변수가 검사한 타입으로 형변환이 가능하다.
		      - 클래스메서드와 클래스변수는 참조변수의 타입에 영향을 받는다.
		      - 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
		      
		     14. 매개변수의 다형성
		      - 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
		      
		     15. 여러객체 배열, Vector
		      - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		      - Vector
		       : 배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
		              이를 Vector클래스를 이용하여 해결할 수 있다.
		       : 동적으로 크기가 관리되는 객체배열 이라고 할 수 있다.
		       
		       	Vector v = new Vector();
		        Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.
		        add()    : Vector에 객체를 추가한다.
		        remove() : Vector에 객체를 삭제한다.
		        isEmpty() : Vector에 객체를 가지고 있는지 확인
		        Object get(int index) : index번째 객체를 반환한다.
		        int size() : Vector 객체가 저장된 개수를 반환한다.
		        
		     16. 추상클래스(abstract class) 
		      - 미완성된 클래스 : 미완성된 메서드를 가지고 있다는 의미
		      - 구성
		        abstract class 클래스명{   
		        
		        }
		      - 추상 메서드
		       : 메서드는 선현부와 구현부로 구성되어있다. 
		       : 추상메서드는 선언부만 작성되어 있고 구현부는 작성되지 않은 메서드를 의미한다.
		       abstract 리턴타입 메서드명();//구현부{} 있으면 안된다.
		      - 추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 클래스의 추상메서드를
		           구현해 주면된다.
		      
		     17. 인터페이스(interface)
		      - 일종의 추상클래스 이지만 추상메서드와 상수만을 멤버로 가진다.
		      - 인터페이스 작성
		        interface 인터페이스명{
		        	public static final 변수타입 변수명 = 값;
		        	public abstract 반환타입 메서드명(매개변수타입 명,...있을수도 없을수도);
		        }
		        
		        : 모든 멤버변수는 public static final 이어야 한다. => 생략할수있다.
		        : 모든 메서드는 public abstract이어야 한다. => 생략할수있다.
		        
		       - 인터페이스의 상속
		        : 인터페이스는 인터페이스만 상속 받을수 있다.
		          => 구현된 메서드를 상속받으면 더이상 인터페이스가 아니게 된다.
		        : 인터페이스는 다중상속 가능하다.
		        : Object와 같은 최고 조상은 없다.
		        
		       - 인터페이스 구현(추상메서드를 구현)
		        : 자체로는 인스턴스를 생성할 수 없다.
		        : 자신이 정의된 추상메서드의 몸통을 만들어 주는 클래스를 작성해야 한다.
		        : 클래스의 확장(extends), 인터페이스의 구현(implements)
		        : ~able
		         => Movable
		         => IMove => IMoveImp1     
		    	
		    	- 인터페이스의 다형성
		    	 : 인터페이스타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할수있다.
		    	  
		    	- 인터페이스의 장점
		    	 : 개발시간을 단축 할 수 있다.
		    	 : 표준화가 가능하다.
		    	 : 서로 관계가 없는 클래스들에게 관계를 맺어줄수 있다.
		    	 : 독립적인 프로그래밍이 가능하다.
		    	 : 7-26예제 꼭 해보기
		    	
		    	- 인터페이스의 이해
		    	 : 클래스를 사용하는 쪽 (user)과 클래스를 제공하는 쪽(provider)이 있다.
		    	 A(제공자,모듈화해서 만들어놓은쪽) - I(선언부) - B(비에서 에이를 부름 , 사용자) 
		    	 
		     18. 내부클래스(inner class)
		       - 내부클래스란?
		        : 클래스 내에 선언된 클래스
		        : 서로 쉽게 접근할수있고 외부에서 볼때 불필요한 클래스를 감춤으로
		              복잡성을 줄일 수있다.
		        
		       - 인스턴스클래스
		        : 외부클래스의 인스턴스 멤버들과 관련된 작업을 수행한다.
		        
		       - 스태틱클래스
		        : 외부클래스의 클래스멤버들과 관련된 작업을 수행, 클래스 메서드를 관련된 작업을 수행한다.
		       
		       - 지역클래스
		        : 외부클래스의 메서드나 초기화 블럭 안에 선언, 선언 영역 내에서만 사용 가능
		         
		       - 익명클래스
				: 클래스의 선언과 객체의 생성을 동시에 진행한다.
		        : 이름이 없는 클래스(일회용)
		        
		         	
		         	
		         	
		         	
		    
		    
		    
		    
		    
		    
		    
		   
		  
		 
		 
		 
		 
		 
		 
		 
		 
		 */
	}
}
